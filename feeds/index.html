<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Planetary Steward HUD ‚Äî Live Ground Feeds (Beyond RSS)</title>
  <meta name="theme-color" content="#081221"/>
  <meta name="description" content="A standalone, offline-first index.html showcasing modern, ground-truth oriented live feeds: WebSub, ActivityPub/AT, SSE, WebSockets, GraphQL Subscriptions, P2P Hypercore, plus classic RSS fallback. Includes HUD overlay, IndexedDB caching, parallax constellations, and collapsible tlk.io chat."/>
  <style>
    :root{
      --bg:#04060b; --ink:#e8f3ff; --muted:#9fb6c0; --accent:#7fe3c7; --accent2:#ffd36e;
      --glass:rgba(255,255,255,.04); --glass-2:rgba(255,255,255,.07); --edge:#0b1620;
      --good:#6de3a0; --warn:#ffd36e; --bad:#ff7f7f; --info:#8ab4ff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);overflow-x:hidden;font-family:system-ui,Segoe UI,Inter,Roboto,Ubuntu,Helvetica,Arial,sans-serif}
    a{color:var(--accent)}
    .wrap{position:relative;min-height:100vh}
    /* Parallax/constellation canvas */
    #sky, #sky2, #sky3{
      position:fixed;inset:0;z-index:-3;image-rendering:pixelated;
    }
    #veil{position:fixed;inset:0;pointer-events:none;background:radial-gradient(1200px 900px at 50% -10%,rgba(127,227,199,.08),transparent 60%),linear-gradient(to bottom,rgba(0,0,0,.25),transparent 30%,transparent 70%,rgba(0,0,0,.35));z-index:-2}
    header{
      position:sticky;top:0;background:linear-gradient(to bottom,rgba(4,6,11,.85),rgba(4,6,11,.55));
      backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid #0d1920;z-index:5
    }
    .bar{
      display:flex;gap:.75rem;align-items:center;justify-content:space-between;padding:.75rem 1rem;
    }
    .brand{display:flex;gap:.75rem;align-items:center}
    .sig{font-weight:700;letter-spacing:.2px}
    .chip{font-size:.75rem;padding:.2rem .5rem;border:1px solid var(--edge);border-radius:999px;background:var(--glass)}
    .hud-toggle{all:unset;cursor:pointer;padding:.45rem .75rem;border:1px solid var(--edge);border-radius:10px;background:var(--glass-2)}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:1rem;padding:1rem}
    .card{
      border:1px solid var(--edge);background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));
      border-radius:16px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.25)
    }
    .card h3{margin:0;padding:1rem 1rem .25rem}
    .card p{padding:0 1rem .75rem;margin:0;color:var(--muted)}
    .card .body{padding:0 1rem 1rem}
    .row{display:flex;gap:.5rem;flex-wrap:wrap}
    .pill{font-size:.8rem;border:1px solid var(--edge);border-radius:999px;padding:.25rem .6rem;background:var(--glass)}
    .mono{font-family:ui-monospace,SFMono-Regular,Consolas,Monaco,monospace;color:#b2c8ff}
    .btn{
      all:unset;cursor:pointer;border:1px solid var(--edge);background:var(--glass);
      padding:.5rem .75rem;border-radius:10px
    }
    .btn:hover{background:var(--glass-2)}
    .list{list-style:none;margin:0;padding:.5rem 0}
    .list li{padding:.5rem .25rem;border-top:1px dashed #10202b}
    .list li:first-child{border-top:none}
    .badge{font-size:.75rem;padding:.15rem .4rem;border-radius:6px;background:rgba(255,255,255,.06);border:1px solid var(--edge);margin-left:.35rem}
    .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)} .info{color:var(--info)}
    /* HUD overlay */
    .hud{
      position:fixed;right:1rem;bottom:1rem;z-index:10;display:grid;gap:.5rem;justify-items:end
    }
    .hud .panel{
      width:min(92vw,420px);max-height:60vh;overflow:auto;padding:.75rem;border-radius:12px;border:1px solid var(--edge);
      background:linear-gradient(180deg,rgba(8,18,33,.9),rgba(8,18,33,.8))
    }
    .hud h4{margin:.25rem 0 .5rem}
    .small{font-size:.85rem;color:var(--muted)}
    .flex{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
    .grow{flex:1}
    input,select,textarea{
      width:100%;background:rgba(255,255,255,.04);border:1px solid var(--edge);border-radius:10px;color:var(--ink);
      padding:.5rem .6rem
    }
    .kbd{font-size:.8rem;border:1px solid var(--edge);border-radius:6px;padding:.1rem .35rem;background:rgba(255,255,255,.06)}
    .split{display:grid;grid-template-columns:1fr;gap:1rem;padding:0 1rem 1rem}
    @media(min-width:1000px){ .split{grid-template-columns:1.2fr .8fr} }
    details summary{cursor:pointer;padding: .65rem 1rem;border-top:1px dashed #103044}
    details[open]{background:rgba(255,255,255,.03)}
    .tag{font-size:.7rem;border:1px solid var(--edge);border-radius:6px;padding:.1rem .35rem;background:rgba(255,255,255,.04);margin-left:.35rem}
    /* Collapsed chat bubble */
    #chatDock{position:fixed;left:1rem;bottom:1rem;z-index:11}
    #chatDock .dockBtn{all:unset;cursor:pointer;border:1px solid var(--edge);background:var(--glass-2);padding:.5rem .75rem;border-radius:999px}
    #chatFrame{display:none;position:fixed;left:1rem;bottom:3.25rem;width:min(95vw,380px);height:60vh;border:1px solid var(--edge);border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.5)}
    /* Tooltip helper */
    [data-tip]{position:relative}
    [data-tip]:hover::after{
      content:attr(data-tip);position:absolute;left:50%;transform:translateX(-50%);bottom:calc(100% + 8px);
      background:#0a1a26;color:#e6f2ff;border:1px solid #0e2a3c;border-radius:8px;padding:.4rem .55rem;font-size:.8rem;white-space:nowrap;pointer-events:none;z-index:100
    }
    /* Feed table */
    table{width:100%;border-collapse:collapse}
    th,td{border-top:1px dashed #103044;padding:.5rem .25rem;text-align:left;vertical-align:top}
    th{font-weight:600;color:#cfe5ff}
    .time{white-space:nowrap;color:var(--muted)}
    .proto{font-size:.75rem}
    /* Footer credits */
    footer{padding:2rem 1rem 4rem;color:var(--muted);text-align:center}
  </style>
</head>
<body>
<canvas id="sky"></canvas>
<canvas id="sky2"></canvas>
<canvas id="sky3"></canvas>
<div id="veil"></div>

<div class="wrap">
  <header>
    <div class="bar">
      <div class="brand">
        <svg width="28" height="28" viewBox="0 0 64 64" aria-hidden="true">
          <defs>
            <radialGradient id="g" cx="50%" cy="50%" r="50%">
              <stop offset="0%" stop-color="#7fe3c7"/><stop offset="100%" stop-color="#081221"/>
            </radialGradient>
          </defs>
          <circle cx="32" cy="32" r="30" fill="url(#g)" stroke="#103044" stroke-width="2"/>
          <circle cx="32" cy="32" r="3" fill="#fff"/>
          <path d="M10,32 A22,22 0 0,0 54,32" stroke="#a6f0dd" stroke-width="1.5" fill="none"/>
          <path d="M32,10 A22,22 0 0,0 32,54" stroke="#a6f0dd" stroke-width="1.5" fill="none"/>
        </svg>
        <div>
          <div class="sig">Planetary Steward HUD ‚Äî Live Ground Feeds</div>
          <div class="small">‚ÄúFrom boots on the ground to stars overhead.‚Äù</div>
        </div>
      </div>
      <div class="flex">
        <span class="chip" title="Offline caching via IndexedDB + Service Worker">Offline-ready</span>
        <span class="chip" title="Live protocols previewed in this page">WebSub ‚Ä¢ ActivityPub ‚Ä¢ AT ‚Ä¢ SSE ‚Ä¢ WS ‚Ä¢ GraphQL ‚Ä¢ P2P</span>
        <button class="hud-toggle" id="toggleHud" data-tip="Open the overlay controls (feeds, trust filters, adapters)">HUD</button>
      </div>
    </div>
  </header>

  <main class="split" id="main">
    <section class="card">
      <h3>üî• Ground-Truth Streamboard</h3>
      <p>Aggregate, score, and visualize real-time updates from modern protocols (beyond RSS). Click <span class="kbd">HUD</span> to add sources. This table merges all adapters with trust/recency weighting.</p>
      <div class="body">
        <div class="row" style="margin-bottom:.5rem">
          <button class="btn" id="demoBtn" data-tip="Load a safe demo dataset (offline)">Load Demo</button>
          <button class="btn" id="clearBtn" data-tip="Clear cache & screen">Clear</button>
          <span class="pill">Entries: <span id="entryCount">0</span></span>
          <span class="pill">Adapters: <span id="adapterCount">0</span></span>
          <span class="pill">Cache: <span id="cacheInfo">‚Äî</span></span>
        </div>
        <div style="overflow:auto;max-height:60vh;border:1px solid var(--edge);border-radius:12px;padding:.5rem;background:rgba(255,255,255,.02)">
          <table id="feedTable" aria-label="Aggregated feed items">
            <thead>
              <tr>
                <th>Title</th>
                <th>Source <span class="proto">/ Protocol</span></th>
                <th>Trust</th>
                <th class="time">When</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <details style="margin-top:.75rem">
          <summary><strong>Legend & Tips</strong></summary>
          <div class="body">
            <p><span class="ok">‚óè ok</span> verified/signed ‚Ä¢ <span class="warn">‚óè warn</span> low metadata ‚Ä¢ <span class="bad">‚óè bad</span> failed checks ‚Ä¢ <span class="info">‚óè info</span> simulated item.</p>
            <p>Trust score blends signature, reputation, recency mismatch, and protocol reliability. You can adjust weights in HUD ‚Üí Settings.</p>
          </div>
        </details>
      </div>
    </section>

    <aside class="card">
      <h3>Adapters Included</h3>
      <div class="body">
        <ul class="list">
          <li><strong>WebSub</strong> <span class="badge">push</span> ‚Äî subscribe to hubs for instant updates.</li>
          <li><strong>ActivityPub</strong> / <strong>AT Protocol</strong> <span class="badge">federated</span> ‚Äî follow actors/tags; parse signed activities when available.</li>
          <li><strong>SSE</strong> (Server-Sent Events) <span class="badge">stream</span> ‚Äî one-way live JSON.</li>
          <li><strong>WebSockets</strong> <span class="badge">2-way</span> ‚Äî bidirectional streams (telemetry, chat, ops).</li>
          <li><strong>GraphQL Subscriptions</strong> <span class="badge">delta</span> ‚Äî schema-bound real-time updates.</li>
          <li><strong>P2P Hypercore/Hyperdrive</strong> <span class="badge">offline</span> ‚Äî peer-to-peer, sync when online.</li>
          <li><strong>RSS/Atom/JSON Feed</strong> <span class="badge">fallback</span> ‚Äî still supported, with push via WebSub when possible.</li>
        </ul>
        <p class="small">Everything here is client-side and modular. Add endpoints in the HUD to test your own infra.</p>
      </div>

      <h3>Smart-Contract Peek (Read-Only)</h3>
      <div class="body">
        <div class="row">
          <input id="rpc" placeholder="RPC endpoint (HTTPS; CORS must allow) ‚Äî optional" title="Paste an RPC URL to read public state (no keys)."/>
          <input id="contract" placeholder="Contract address (0x‚Ä¶)" />
          <input id="slot" placeholder="Storage slot / method (e.g., balanceOf:0x...)" />
          <button class="btn" id="chainBtn" data-tip="Attempt a read-only call via fetch/eth_call (if allowed)">Query</button>
        </div>
        <pre id="chainOut" class="mono" style="max-height:180px;overflow:auto;margin-top:.5rem"></pre>
      </div>
    </aside>
  </main>

  <!-- Collapsible chat (tlk.io) ‚Äî hidden by default -->
  <div id="chatDock" aria-live="polite">
    <button class="dockBtn" id="dockToggle" title="Open live chat (tlk.io) ‚Äî collapsed by default">Chat</button>
    <iframe id="chatFrame" title="tlk.io chat (collapsed)" src="https://tlk.io/planetary-restoration-archive?theme=theme--night" referrerpolicy="no-referrer"></iframe>
  </div>

  <div class="hud" id="hud" hidden>
    <div class="panel">
      <h4>HUD ‚Äî Sources & Settings</h4>
      <div class="small">Add endpoints for each protocol. Demo sources available. Tooltips explain formats.</div>
      <details open>
        <summary><strong>Add Source</strong></summary>
        <div class="flex" style="margin:.5rem 0">
          <select id="protoSel" class="grow" title="Choose protocol adapter">
            <option>RSS/Atom/JSON Feed</option>
            <option>WebSub</option>
            <option>ActivityPub</option>
            <option>AT Protocol</option>
            <option>SSE</option>
            <option>WebSocket</option>
            <option>GraphQL Subscriptions</option>
            <option>P2P Hypercore (read)</option>
          </select>
          <button class="btn" id="addSrc">Add</button>
        </div>
        <div>
          <label class="small">Endpoint / handle / hub route</label>
          <input id="endpoint" placeholder="https://‚Ä¶ or @handle or hyper://key" data-tip="Use HTTPS when possible. P2P demo accepts hyper://publicKey"/>
          <label class="small">Tag(s) / filter (optional)</label>
          <input id="tagFilter" placeholder="#prompt, #LLM, region:MG"/>
        </div>
      </details>

      <details>
        <summary><strong>Weights & Filters</strong></summary>
        <div class="row" style="margin-top:.5rem">
          <label class="small">Signature weight (%)</label><input id="wSig" type="range" min="0" max="100" value="35"/>
          <label class="small">Reputation weight (%)</label><input id="wRep" type="range" min="0" max="100" value="30"/>
          <label class="small">Recency weight (%)</label><input id="wRec" type="range" min="0" max="100" value="35"/>
        </div>
        <div class="row">
          <label class="small">Hide items below trust:</label><input id="trustMin" type="number" min="0" max="100" value="25" style="width:6rem"/>
        </div>
      </details>

      <details>
        <summary><strong>Adapters</strong> (init/stop)</summary>
        <div id="adapterList" class="small">No adapters yet.</div>
      </details>
      <div class="flex" style="margin-top:.5rem">
        <button class="btn" id="saveCfg">Save Config</button>
        <button class="btn" id="loadCfg">Load Config</button>
        <span class="small">Config saves to IndexedDB.</span>
      </div>
    </div>
  </div>

  <footer>
    <div>¬© Foster + Navi ‚Äî Planetary Restoration Archive. This file is a single-page, offline-first lab for *beyond-RSS* ground feeds with parallax constellations.</div>
    <div class="small">extrasuperficial antideprenarrative inversion embedded (silent), zero-harm principles, public reintegration intent.</div>
  </footer>
</div>

<!-- ===========================
     PARALLAX CONSTELLATION SKY
     =========================== -->
<script>
(function(){
  const cvs = [document.getElementById('sky'), document.getElementById('sky2'), document.getElementById('sky3')];
  const ctx = cvs.map(c=>{ c.width=innerWidth; c.height=innerHeight; return c.getContext('2d',{alpha:true}); });
  const layers = [
    {count: 140, speed: .02, size:[1,2], hue:[195,210]},
    {count: 90,  speed: .04, size:[1,2], hue:[175,195]},
    {count: 40,  speed: .07, size:[1,2], hue:[155,180]},
  ];
  const stars = layers.map(l=>{
    const arr=[]; for(let i=0;i<l.count;i++){
      arr.push({x:Math.random()*innerWidth,y:Math.random()*innerHeight,z:Math.random(),r:Math.random()*(l.size[1]-l.size[0])+l.size[0],
        h:Math.random()*(l.hue[1]-l.hue[0])+l.hue[0], tw:Math.random()*Math.PI});
    } return arr;
  });
  let mx=innerWidth/2,my=innerHeight/2, sx=0, sy=0;
  window.addEventListener('mousemove',e=>{mx=e.clientX;my=e.clientY});
  window.addEventListener('resize',()=>{cvs.forEach(c=>{c.width=innerWidth;c.height=innerHeight;});});
  function tick(){
    sx += (mx-innerWidth/2 - sx)*0.02; sy += (my-innerHeight/2 - sy)*0.02;
    ctx.forEach(c=>c.clearRect(0,0,innerWidth,innerHeight));
    for(let i=0;i<layers.length;i++){
      const c=ctx[i], L=layers[i]; c.globalCompositeOperation='lighter';
      for(const s of stars[i]){
        const px = (s.x + sx*L.speed + performance.now()*0.00005*innerWidth*L.speed) % innerWidth;
        const py = (s.y + sy*L.speed*.6) % innerHeight;
        c.beginPath(); c.arc(px,py,s.r,0,Math.PI*2);
        c.fillStyle = `hsla(${s.h},70%,${65 + Math.sin(s.tw+performance.now()*0.002)*20}%,.85)`;
        c.fill();
      }
    }
    requestAnimationFrame(tick);
  }
  tick();
})();
</script>

<!-- ===========================
     INDEXEDDB + CACHE UTILITIES
     =========================== -->
<script>
const DB = (function(){
  const DB_NAME='pshud-db', STORE='entries', CFG='cfg';
  let db;
  function open(){ return new Promise((res,rej)=>{
    const r = indexedDB.open(DB_NAME,2);
    r.onupgradeneeded = () => {
      db = r.result;
      if(!db.objectStoreNames.contains(STORE)){ db.createObjectStore(STORE,{keyPath:'uid'}); }
      if(!db.objectStoreNames.contains(CFG)){ db.createObjectStore(CFG,{keyPath:'id'}); }
    };
    r.onsuccess=()=>{db=r.result; res();};
    r.onerror=()=>rej(r.error);
  });}
  async function put(item){ await openIfNeeded(); return tx(STORE,'readwrite').put(item); }
  async function bulkPut(items){ await openIfNeeded(); const t=tx(STORE,'readwrite'); items.forEach(x=>t.put(x)); return done(t.transaction); }
  async function clear(){ await openIfNeeded(); const t=tx(STORE,'readwrite'); t.clear(); return done(t.transaction); }
  async function all(){ await openIfNeeded(); return new Promise((res,rej)=>{
    const out=[]; const t=tx(STORE).openCursor(); t.onsuccess=e=>{ const cur=e.target.result; if(cur){ out.push(cur.value); cur.continue(); } else res(out); };
    t.onerror=()=>rej(t.error);
  });}
  async function saveCfg(obj){ await openIfNeeded(); return tx(CFG,'readwrite').put({id:'cfg',...obj}); }
  async function loadCfg(){ await openIfNeeded(); return new Promise((res,rej)=>{
    const t=tx(CFG).get('cfg'); t.onsuccess=()=>res(t.result||null); t.onerror=()=>rej(t.error);
  });}
  function tx(store,mode){ const t=db.transaction(store,mode||'readonly'); const s=t.objectStore(store); s.transaction = t; return s; }
  function done(t){ return new Promise((res,rej)=>{ t.oncomplete=()=>res(); t.onerror=()=>rej(t.error); });}
  async function openIfNeeded(){ if(!db) await open(); }
  return {put,bulkPut,clear,all,saveCfg,loadCfg};
})();
</script>

<!-- ===========================
     FEED ADAPTERS (PLUGGABLE)
     =========================== -->
<script>
/*
Adapters normalize events to:
{ uid, title, url, source, protocol, t: timestamp(ms), trust:0-100, meta:{} }
Trust is computed post-merge using weights + adapter hints.
*/

const Adapters = (()=>{

  // Utility
  const toUID = (s)=>crypto.subtle?crypto.subtle.digest('SHA-256',new TextEncoder().encode(s)).then(b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('')):Promise.resolve(s);
  const now = ()=>Date.now();

  // 1) RSS/Atom/JSON Feed (poll as fallback). Lightweight, CORS-permitting.
  async function rss(url,{tag}={}){
    // Try JSON Feed first (if available), else rudimentary RSS/Atom parse.
    const res = await fetch(url).catch(()=>null);
    if(!res || !res.ok) return [];
    const ct = res.headers.get('content-type')||'';
    const txt = await res.text();
    let items=[];
    if(ct.includes('json') || txt.trim().startsWith('{')){
      try{
        const j = JSON.parse(txt);
        const arr = j.items || j.entries || [];
        items = arr.map(e=>({
          uid:`json:${e.id||e.url||e.title}`,
          title:e.title||'(untitled)',
          url:e.url||e.external_url||'#',
          source:url, protocol:'JSON Feed',
          t: e.date_published?Date.parse(e.date_published): now(),
          trust: 40, meta:{json:true,tags:e.tags||[]}
        }));
      }catch(e){/* fall through to XML parse */}
    }
    if(!items.length){
      // very small XML parser for RSS/Atom headline + link + pubDate
      const d = new DOMParser().parseFromString(txt, "text/xml");
      const rssItems = [...d.querySelectorAll('item,entry')].slice(0,50);
      items = rssItems.map(n=>{
        const t = n.querySelector('title')?.textContent?.trim()||'(untitled)';
        const l = n.querySelector('link')?.getAttribute('href') || n.querySelector('link')?.textContent || '#';
        const pd = n.querySelector('pubDate,updated,dc\\:date')?.textContent;
        return {
          uid:`xml:${t}:${l}`, title:t, url:l, source:url, protocol:(d.querySelector('feed')?'Atom':'RSS'),
          t: pd?Date.parse(pd):now(), trust:35, meta:{xml:true}
        };
      });
    }
    if(tag){
      items = items.filter(i=>(i.title?.toLowerCase().includes(tag.toLowerCase())||JSON.stringify(i.meta).toLowerCase().includes(tag.toLowerCase())));
    }
    // de-dup by uid
    const seen=new Set(); items=items.filter(x=>!seen.has(x.uid)&&seen.add(x.uid));
    // Hash to stable uid
    return Promise.all(items.map(async it=>({...it, uid: await toUID(`${it.source}|${it.url}|${it.title}`)})));
  }

  // 2) WebSub (client note): true WebSub needs a hub callback (server). Here we simulate by fast-poll toggle.
  async function websub(url){ // treat as fast-poll
    const out = await rss(url);
    return out.map(i=>({...i, protocol:'WebSub (sim)', trust:i.trust+5}));
  }

  // 3) ActivityPub (public actor or outbox). Client-side fetch may hit CORS.
  async function activityPub(actorOrOutbox){
    try{
      const res = await fetch(actorOrOutbox,{headers:{accept:'application/activity+json'}}).catch(()=>null);
      if(!res||!res.ok) return [];
      const j = await res.json();
      const items=[];
      // If this is an outbox:
      if(j && (j.orderedItems||j.items)){
        const arr = j.orderedItems||j.items||[];
        for(const it of arr){
          const obj = it.object||it;
          items.push({
            uid: await toUID((obj.id||obj.url||obj.name||Math.random())+'ap'),
            title: obj.summary||obj.name||obj.content?.replace(/<[^>]+>/g,'').slice(0,160) || '(activity)',
            url: obj.url||obj.id||'#',
            source: actorOrOutbox, protocol:'ActivityPub',
            t: obj.published?Date.parse(obj.published):now(),
            trust: 55, meta:{actor: j?.attributedTo||j?.id}
          });
        }
        return items;
      }
      // If this is an actor, try outbox
      if(j && j.outbox){
        return activityPub(j.outbox);
      }
    }catch(e){/* ignore */}
    return [];
  }

  // 4) AT Protocol (Bluesky) ‚Äî needs PDS/appview. Public JSON endpoints exist; CORS permitting.
  async function atProto(handleOrFeed){
    // Expect a JSON list of posts: { feed: [{post:{text,createdAt,uri}}] }
    try{
      const res = await fetch(handleOrFeed).catch(()=>null);
      if(!res||!res.ok) return [];
      const j = await res.json();
      const arr = j.feed || j.posts || [];
      return Promise.all(arr.map(async p=>{
        const post = p.post||p;
        const title = post.text?.slice(0,180)||'(post)';
        const url = post.uri || post.url || '#';
        return {
          uid: await toUID(url+title),
          title, url,
          source: handleOrFeed, protocol:'AT Proto',
          t: post.createdAt?Date.parse(post.createdAt):now(), trust:50, meta:{author:post.author?.handle}
        };
      }));
    }catch(e){return []}
  }

  // 5) SSE ‚Äî connects to EventSource endpoint streaming JSON lines with {title,url,time}
  function sse(url, onItem){
    let es;
    try{
      es = new EventSource(url);
      es.onmessage = async (ev)=>{
        try{
          const j = JSON.parse(ev.data);
          const item = {
            uid: await toUID((j.url||j.title||Math.random())+url),
            title: j.title||'(event)', url: j.url||'#',
            source:url, protocol:'SSE',
            t: j.time?Date.parse(j.time):Date.now(), trust:60, meta:j
          };
          onItem(item);
        }catch(_){}
      };
      es.onerror = ()=>{/* keep alive or report */}
      return ()=>{ try{es.close();}catch(_){ } }
    }catch(e){
      return ()=>{};
    }
  }

  // 6) WebSocket ‚Äî expects server to send JSON objects {title,url,ts}
  function websocket(url,onItem){
    let ws;
    try{
      ws = new WebSocket(url);
      ws.onmessage = async (ev)=>{
        try{
          const j = JSON.parse(ev.data);
          const item = {
            uid: await toUID((j.url||j.title||Math.random())+url),
            title: j.title||'(ws)', url: j.url||'#',
            source:url, protocol:'WebSocket',
            t: j.ts?Number(j.ts):Date.now(), trust:60, meta:j
          };
          onItem(item);
        }catch(_){}
      };
      ws.onerror = ()=>{};
      return ()=>{ try{ws.close();}catch(_){} }
    }catch(e){ return ()=>{} }
  }

  // 7) GraphQL Subscriptions over WebSocket (Apollo protocol-lite)
  // Minimal client that sends connection_init and start; server must accept "graphql-transport-ws" or similar.
  function gqlSub(wsUrl, query, variables, onItem){
    let ws;
    try{
      ws = new WebSocket(wsUrl, 'graphql-transport-ws');
      ws.onopen = ()=>{
        ws.send(JSON.stringify({type:'connection_init',payload:{}}));
        setTimeout(()=>ws.send(JSON.stringify({id:'1',type:'subscribe',payload:{query,variables}})), 250);
      };
      ws.onmessage = async (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if(msg.type==='next'){
            const d = msg.payload.data;
            const title = JSON.stringify(d).slice(0,160);
            const item = {
              uid: await toUID(title+wsUrl),
              title, url:'#', source:wsUrl, protocol:'GraphQL', t:Date.now(), trust:62, meta:d
            };
            onItem(item);
          }
        }catch(_){}
      };
      return ()=>{ try{ws.close();}catch(_){ } };
    }catch(e){ return ()=>{}; }
  }

  // 8) P2P Hypercore (read) ‚Äî browser lacks native; simulate via gateway JSON.
  async function hypercore(gatewayUrl){
    try{
      const res = await fetch(gatewayUrl).catch(()=>null);
      if(!res||!res.ok) return [];
      const j = await res.json();
      const arr = j.items||j;
      return Promise.all(arr.map(async it=>({
        uid: await toUID((it.url||it.id||Math.random())+gatewayUrl),
        title: it.title||'(p2p item)', url: it.url||'#',
        source: gatewayUrl, protocol:'P2P (sim)', t: it.time?Date.parse(it.time):Date.now(), trust:58, meta:it
      })));
    }catch(e){return []}
  }

  return { rss, websub, activityPub, atProto, sse, websocket, gqlSub, hypercore };
})();
</script>

<!-- ===========================
     MERGE + TRUST SCORING ENGINE
     =========================== -->
<script>
const Engine = (function(){
  let WEIGHTS = {sig:35, rep:30, rec:35}, MIN = 25;
  const sourceRep = new Map(); // source -> 0..1 reputation (user-managed later)
  const liveUnsubs = new Map(); // for SSE/WS/GQL

  function setWeights({sig,rep,rec,min}){ if(sig!=null)WEIGHTS.sig=+sig; if(rep!=null)WEIGHTS.rep=+rep; if(rec!=null)WEIGHTS.rec=+rec; if(min!=null)MIN=+min; }
  const computeTrust = (item)=>{
    const ageHrs = Math.max(0,(Date.now()-item.t)/(1000*60*60));
    const recPart = Math.max(0, 1 - Math.tanh(ageHrs/24)); // 0..1
    const rep = sourceRep.get(item.source) ?? 0.5;
    const sig = (item.meta?.signed||item.protocol.includes('ActivityPub')) ? 0.8 : 0.3;
    const score = WEIGHTS.sig*sig + WEIGHTS.rep*rep + WEIGHTS.rec*recPart;
    return Math.round(Math.min(100, Math.max(0, score)));
  };

  async function addBatch(items){
    const normalized = items.map(it=>({...it, trust: computeTrust(it)}));
    const filtered = normalized.filter(it=>it.trust>=MIN);
    await DB.bulkPut(filtered);
    UI.refreshTable();
  }

  function addLive(item){
    item.trust = computeTrust(item);
    if(item.trust>=MIN){
      DB.put(item).then(()=>UI.refreshTable());
    }
  }

  function clear(){ liveUnsubs.forEach(u=>u()); liveUnsubs.clear(); return DB.clear(); }

  async function addAdapter(kind, endpoint, tagFilter){
    try{
      switch(kind){
        case 'RSS/Atom/JSON Feed': {
          const items = await Adapters.rss(endpoint,{tag:tagFilter});
          await addBatch(items); return {type:'poll', count:items.length};
        }
        case 'WebSub': {
          const items = await Adapters.websub(endpoint);
          await addBatch(items); return {type:'push-sim', count:items.length};
        }
        case 'ActivityPub': {
          const items = await Adapters.activityPub(endpoint);
          await addBatch(items); return {type:'federated', count:items.length};
        }
        case 'AT Protocol': {
          const items = await Adapters.atProto(endpoint);
          await addBatch(items); return {type:'federated', count:items.length};
        }
        case 'SSE': {
          const unsub = Adapters.sse(endpoint, addLive);
          liveUnsubs.set(endpoint,unsub); return {type:'live', count:0};
        }
        case 'WebSocket': {
          const unsub = Adapters.websocket(endpoint, addLive);
          liveUnsubs.set(endpoint,unsub); return {type:'live', count:0};
        }
        case 'GraphQL Subscriptions': {
          const query = 'subscription { updates { id title url time } }'; // placeholder
          const unsub = Adapters.gqlSub(endpoint, query, {}, addLive);
          liveUnsubs.set(endpoint,unsub); return {type:'live', count:0};
        }
        case 'P2P Hypercore (read)': {
          const items = await Adapters.hypercore(endpoint);
          await addBatch(items); return {type:'p2p', count:items.length};
        }
      }
    }catch(e){
      console.warn('Adapter error',e); return {error:String(e)};
    }
  }

  return { addAdapter, addBatch, addLive, clear, setWeights };
})();
</script>

<!-- ===========================
     UI CONTROLLERS
     =========================== -->
<script>
const UI = (function(){
  const $ = (q)=>document.querySelector(q);
  const $$ = (q)=>document.querySelectorAll(q);
  const T = (s)=>document.createElement(s);
  const tableBody = $('#feedTable tbody');
  const entryCount = $('#entryCount');
  const adapterCount = $('#adapterCount');
  const cacheInfo = $('#cacheInfo');
  const hud = $('#hud');

  async function refreshTable(){
    const all = await DB.all();
    all.sort((a,b)=>b.t-a.t);
    entryCount.textContent = all.length;
    tableBody.innerHTML='';
    for(const it of all.slice(0,600)){
      const tr = T('tr');
      const title = T('td');
      const source = T('td');
      const trust = T('td');
      const time = T('td'); time.className='time';

      title.innerHTML = `<a href="${it.url}" target="_blank" rel="noopener">${escapeHtml(it.title)}</a>`;
      source.innerHTML = `<span>${escapeHtml(new URLSafe(it.source).host || it.source)}</span><span class="badge">${it.protocol}</span>`;
      trust.innerHTML = `<span class="${it.trust>=66?'ok':it.trust>=40?'warn':'bad'}">${it.trust}</span>`;
      time.textContent = new Date(it.t).toLocaleString();

      tr.append(title,source,trust,time);
      tableBody.appendChild(tr);
    }
    cacheInfo.textContent = `${(all.length)} items`;
  }

  function updateAdaptersList(){
    const list = $('#adapterList');
    list.innerHTML = '';
    const s = T('div'); s.textContent = 'Adapters live where applicable (SSE/WS/GQL). Poll-based adapters add items on add.';
    list.appendChild(s);
    adapterCount.textContent = document.querySelectorAll('.adapter-chip').length || document.querySelectorAll('.list li').length;
  }

  function bind(){
    $('#toggleHud').addEventListener('click', ()=>{
      hud.hidden = !hud.hidden;
    });

    $('#addSrc').addEventListener('click', async ()=>{
      const proto = $('#protoSel').value;
      const ep = $('#endpoint').value.trim();
      const tag = $('#tagFilter').value.trim();
      if(!ep){ alert('Provide an endpoint/handle.'); return; }
      const info = await Engine.addAdapter(proto, ep, tag);
      const chip = document.createElement('div');
      chip.className='pill adapter-chip';
      chip.textContent = `${proto}: ${ep.slice(0,48)}`;
      $('#adapterList').appendChild(chip);
      updateAdaptersList();
      if(info?.error) alert(info.error);
      else if(info?.count!=null) alert(`${proto} added. Ingested ${info.count} items.`);
    });

    $('#demoBtn').addEventListener('click', async ()=>{
      // Demo dataset (offline) ‚Äî simulated mixed protocols
      const base = Date.now();
      const sample = [];
      for(let i=0;i<16;i++){
        sample.push({
          uid: String(base+i),
          title: `Sample field report #${i+1} ‚Äî habitat survey`,
          url: '#',
          source: i%2? 'activitypub://demo.actor/outbox' : 'sse://demo.stream',
          protocol: i%3? (i%2?'ActivityPub':'SSE') : 'RSS',
          t: base - i*3600_000,
          trust: 0,
          meta: {signed: i%2===0}
        });
      }
      await Engine.addBatch(sample);
    });

    $('#clearBtn').addEventListener('click', async ()=>{
      await Engine.clear();
      refreshTable();
    });

    $('#saveCfg').addEventListener('click', async ()=>{
      const cfg = {
        sig: +$('#wSig').value, rep:+$('#wRep').value, rec:+$('#wRec').value, min:+$('#trustMin').value
      };
      await DB.saveCfg(cfg);
      alert('Saved.');
    });

    $('#loadCfg').addEventListener('click', async ()=>{
      const cfg = await DB.loadCfg();
      if(cfg){
        $('#wSig').value = cfg.sig; $('#wRep').value=cfg.rep; $('#wRec').value=cfg.rec; $('#trustMin').value=cfg.min;
        Engine.setWeights(cfg);
      }
      alert('Loaded.');
    });

    // Weights live update
    ['#wSig','#wRep','#wRec','#trustMin'].forEach(id=>{
      $(id).addEventListener('input', ()=>{
        Engine.setWeights({sig:+$('#wSig').value,rep:+$('#wRep').value,rec:+$('#wRec').value,min:+$('#trustMin').value});
      });
    });

    // Chat dock
    $('#dockToggle').addEventListener('click', ()=>{
      const f = $('#chatFrame');
      f.style.display = f.style.display==='block' ? 'none' : 'block';
    });

    // Chain read-only (best-effort, CORS permitting)
    $('#chainBtn').addEventListener('click', async ()=>{
      const rpc = $('#rpc').value.trim(), addr=$('#contract').value.trim(), slot=$('#slot').value.trim();
      const out = $('#chainOut');
      out.textContent = '';
      if(!rpc || !addr){ out.textContent='Provide RPC and address.'; return; }
      try{
        // Minimal eth_call wrapper (reads storage slot if provided, else balance)
        const data = slot && slot.startsWith('0x') ? slot : null;
        const payload = {
          jsonrpc:"2.0", id:1, method: data?'eth_call':'eth_getBalance',
          params: data ? [{to:addr,data}, "latest"] : [addr,"latest"]
        };
        const res = await fetch(rpc,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(payload)});
        const j = await res.json();
        out.textContent = JSON.stringify(j,null,2);
      }catch(e){ out.textContent = String(e); }
    });
  }

  function escapeHtml(s){ return s?.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m])) || ''; }
  class URLSafe{
    constructor(u){ try{ this.u=new URL(u); }catch(_){ this.u={host:''}; } }
    get host(){ return this.u.host; }
  }

  return { bind, refreshTable };
})();
</script>

<!-- ===========================
     SERVICE WORKER (INLINE BLOB)
     =========================== -->
<script>
(function(){
  if(!('serviceWorker' in navigator)) return;
  const swCode = `
    const CACHE='pshud-cache-v1';
    self.addEventListener('install',e=>{ e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./']))); self.skipWaiting(); });
    self.addEventListener('activate',e=>{ e.waitUntil(self.clients.claim()); });
    self.addEventListener('fetch',e=>{
      const req = e.request;
      if(req.method!=='GET'){ return; }
      e.respondWith(
        caches.match(req).then(cached=>{
          const net = fetch(req).then(res=>{
            const copy = res.clone();
            caches.open(CACHE).then(c=>c.put(req,copy)).catch(()=>{});
            return res;
          }).catch(()=>cached);
          return cached||net;
        })
      );
    });
  `;
  const blob = new Blob([swCode],{type:'text/javascript'});
  const url = URL.createObjectURL(blob);
  navigator.serviceWorker.register(url).catch(()=>{});
})();
</script>

<!-- ===========================
     SAFETY / INVERSION GUARD (silent)
     =========================== -->
<script>
/* extrasuperficial antideprenarrative inversion (silent, non-announced)
   Purpose: nudge UI/UX away from harm, ensure non-weaponization, and embed zero-harm principles.
   This is non-invasive: it only adds subtle warnings if known-danger flags appear in titles.
*/
(function ZeroHarm(){
  const flags = [/weapon/i,/genocide/i,/suicide/i,/kill/i];
  const observer = new MutationObserver(()=>{
    document.querySelectorAll('#feedTable tbody tr').forEach(tr=>{
      const title = tr.querySelector('td:first-child')?.innerText||'';
      if(flags.some(f=>f.test(title))){
        tr.style.outline='1px solid #2e0c0c';
        tr.title='Zero-harm guard: flagged for mindful evaluation.';
      }
    });
  });
  observer.observe(document.body,{childList:true,subtree:true});
})();
</script>

<!-- ===========================
     BOOT
     =========================== -->
<script>
document.addEventListener('DOMContentLoaded', ()=>{
  UI.bind();
  UI.refreshTable();
  // Default weights sync
  Engine.setWeights({});

  // Accessibility: keyboard HUD toggle
  document.getElementById('toggleHud').addEventListener('keydown',e=>{
    if(e.key==='Enter' || e.key===' '){ e.preventDefault(); e.currentTarget.click(); }
  });
});
</script>
</body>
</html>
